*DECK ZVODE
      SUBROUTINE ZVODE (F, NEQ, Y, T, TOUT, ITOL, RTOL, ATOL, ITASK,
     1            ISTATE, IOPT, ZWORK, LZW, RWORK, LRW, IWORK, LIW,
     2            JAC, MF, RPAR, IPAR)
      EXTERNAL F, JAC
      DOUBLE COMPLEX Y, ZWORK
      DOUBLE PRECISION T, TOUT, RTOL, ATOL, RWORK
      INTEGER NEQ, ITOL, ITASK, ISTATE, IOPT, LZW, LRW, IWORK, LIW,
     1        MF, IPAR
      DIMENSION Y(*), RTOL(*), ATOL(*), ZWORK(LZW), RWORK(LRW),
     1          IWORK(LIW), RPAR(*), IPAR(*)
C-----------------------------------------------------------------------
C ZVODE: Variable-coefficient Ordinary Differential Equation solver,
C with fixed-leading-coefficient implementation.
C This version is in complex double precision.
C
C ZVODE solves the initial value problem for stiff or nonstiff
C systems of first order ODEs,
C     dy/dt = f(t,y) ,  or, in component form,
C     dy(i)/dt = f(i) = f(i,t,y(1),y(2),...,y(NEQ)) (i = 1,...,NEQ).
C Here the y vector is treated as complex.
C ZVODE is a package based on the EPISODE and EPISODEB packages, and
C on the ODEPACK user interface standard, with minor modifications.et 
C
C NOTE: When using ZVODE for a stiff system, it should only be used for
C the case in which the function f is analytic, that is, when each f(i)
C is an analytic function of each y(j).  Analyticity means that the
C partial derivative df(i)/dy(j) is a unique complex number, and this
C fact is critical in the way ZVODE solves the dense or banded linear
C systems that arise in the stiff case.  For a complex stiff ODE system
C in which f is not analytic, ZVODE is likely to have convergence
C failures, and for this problem one should instead use DVODE on the
C equivalent real system (in the real and imaginary parts of y).
C-----------------------------------------------------------------------
C Authors:
C               Peter N. Brown and Alan C. Hindmarsh
C               Center for Applied Scientific Computing
C               Lawrence Livermore National Laboratory
C               Livermore, CA 94551
C and
C               George D. Byrne (Prof. Emeritus)
C               Illinois Institute of Technology
C               Chicago, IL 60616
C-----------------------------------------------------------------------
C For references, see DVODE.
C-----------------------------------------------------------------------
C Summary of usage.
C
C Communication between the user and the ZVODE package, for normal
C situations, is summarized here.  This summary describes only a subset
C of the full set of options available.  See the full description for
C details, including optional communication, nonstandard options,
C and instructions for special situations.  See also the example
C problem (with program and output) following this summary.
C
C A. First provide a subroutine of the form:
C           SUBROUTINE F (NEQ, T, Y, YDOT, RPAR, IPAR)
C           DOUBLE COMPLEX Y(NEQ), YDOT(NEQ)
C           DOUBLE PRECISION T
C which supplies the vector function f by loading YDOT(i) with f(i).
C
C B. Next determine (or guess) whether or not the problem is stiff.
C Stiffness occurs when the Jacobian matrix df/dy has an eigenvalue
C whose real part is negative and large in magnitude, compared to the
C reciprocal of the t span of interest.  If the problem is nonstiff,
C use a method flag MF = 10.  If it is stiff, there are four standard
C choices for MF (21, 22, 24, 25), and ZVODE requires the Jacobian
C matrix in some form.  In these cases (MF .gt. 0), ZVODE will use a
C saved copy of the Jacobian matrix.  If this is undesirable because of
C storage limitations, set MF to the corresponding negative value
C (-21, -22, -24, -25).  (See full description of MF below.)
C The Jacobian matrix is regarded either as full (MF = 21 or 22),
C or banded (MF = 24 or 25).  In the banded case, ZVODE requires two
C half-bandwidth parameters ML and MU.  These are, respectively, the
C widths of the lower and upper parts of the band, excluding the main
C diagonal.  Thus the band consists of the locations (i,j) with
C i-ML .le. j .le. i+MU, and the full bandwidth is ML+MU+1.
C
C C. If the problem is stiff, you are encouraged to supply the Jacobian
C directly (MF = 21 or 24), but if this is not feasible, ZVODE will
C compute it internally by difference quotients (MF = 22 or 25).
C If you are supplying the Jacobian, provide a subroutine of the form:
C           SUBROUTINE JAC (NEQ, T, Y, ML, MU, PD, NROWPD, RPAR, IPAR)
C           DOUBLE COMPLEX Y(NEQ), PD(NROWPD,NEQ)
C           DOUBLE PRECISION T
C which supplies df/dy by loading PD as follows:
C     For a full Jacobian (MF = 21), load PD(i,j) with df(i)/dy(j),
C the partial derivative of f(i) with respect to y(j).  (Ignore the
C ML and MU arguments in this case.)
C     For a banded Jacobian (MF = 24), load PD(i-j+MU+1,j) with
C df(i)/dy(j), i.e. load the diagonal lines of df/dy into the rows of
C PD from the top down.
C     In either case, only nonzero elements need be loaded.
C
C D. Write a main program which calls subroutine ZVODE once for
C each point at which answers are desired.  This should also provide
C for possible use of logical unit 6 for output of error messages
C by ZVODE.  On the first call to ZVODE, supply arguments as follows:
C F      = Name of subroutine for right-hand side vector f.
C          This name must be declared external in calling program.
C NEQ    = Number of first order ODEs.
C Y      = Double complex array of initial values, of length NEQ.
C T      = The initial value of the independent variable.
C TOUT   = First point where output is desired (.ne. T).
C ITOL   = 1 or 2 according as ATOL (below) is a scalar or array.
C RTOL   = Relative tolerance parameter (scalar).
C ATOL   = Absolute tolerance parameter (scalar or array).
C          The estimated local error in Y(i) will be controlled so as
C          to be roughly less (in magnitude) than
C             EWT(i) = RTOL*abs(Y(i)) + ATOL     if ITOL = 1, or
C             EWT(i) = RTOL*abs(Y(i)) + ATOL(i)  if ITOL = 2.
C          Thus the local error test passes if, in each component,
C          either the absolute error is less than ATOL (or ATOL(i)),
C          or the relative error is less than RTOL.
C          Use RTOL = 0.0 for pure absolute error control, and
C          use ATOL = 0.0 (or ATOL(i) = 0.0) for pure relative error
C          control.  Caution: Actual (global) errors may exceed these
C          local tolerances, so choose them conservatively.
C ITASK  = 1 for normal computation of output values of Y at t = TOUT.
C ISTATE = Integer flag (input and output).  Set ISTATE = 1.
C IOPT   = 0 to indicate no optional input used.
C ZWORK  = Double precision complex work array of length at least:
C             15*NEQ                      for MF = 10,
C             8*NEQ + 2*NEQ**2            for MF = 21 or 22,
C             10*NEQ + (3*ML + 2*MU)*NEQ  for MF = 24 or 25.
C LZW    = Declared length of ZWORK (in user's DIMENSION statement).
C RWORK  = Real work array of length at least 20 + NEQ.
C LRW    = Declared length of RWORK (in user's DIMENSION statement).
C IWORK  = Integer work array of length at least:
C             30        for MF = 10,
C             30 + NEQ  for MF = 21, 22, 24, or 25.
C          If MF = 24 or 25, input in IWORK(1),IWORK(2) the lower
C          and upper half-bandwidths ML,MU.
C LIW    = Declared length of IWORK (in user's DIMENSION statement).
C JAC    = Name of subroutine for Jacobian matrix (MF = 21 or 24).
C          If used, this name must be declared external in calling
C          program.  If not used, pass a dummy name.
C MF     = Method flag.  Standard values are:
C          10 for nonstiff (Adams) method, no Jacobian used.
C          21 for stiff (BDF) method, user-supplied full Jacobian.
C          22 for stiff method, internally generated full Jacobian.
C          24 for stiff method, user-supplied banded Jacobian.
C          25 for stiff method, internally generated banded Jacobian.
C RPAR   = user-defined real or complex array passed to F and JAC.
C IPAR   = user-defined integer array passed to F and JAC.
C Note that the main program must declare arrays Y, ZWORK, RWORK, IWORK,
C and possibly ATOL, RPAR, and IPAR.  RPAR may be declared REAL, DOUBLE,
C COMPLEX, or DOUBLE COMPLEX, depending on the user's needs.
C
C E. The output from the first call (or any call) is:
C      Y = Array of computed values of y(t) vector.
C      T = Corresponding value of independent variable (normally TOUT).
C ISTATE = 2  if ZVODE was successful, negative otherwise.
C          -1 means excess work done on this call. (Perhaps wrong MF.)
C          -2 means excess accuracy requested. (Tolerances too small.)
C          -3 means illegal input detected. (See printed message.)
C          -4 means repeated error test failures. (Check all input.)
C          -5 means repeated convergence failures. (Perhaps bad
C             Jacobian supplied or wrong choice of MF or tolerances.)
C          -6 means error weight became zero during problem. (Solution
C             component i vanished, and ATOL or ATOL(i) = 0.)
C
C F. To continue the integration after a successful return, simply
C reset TOUT and call ZVODE again.  No other parameters need be reset.
C
C-----------------------------------------------------------------------
C EXAMPLE PROBLEM
C
C The program below uses ZVODE to solve the following system of 2 ODEs:
C dw/dt = -i*w*w*z, dz/dt = i*z; w(0) = 1/2.1, z(0) = 1; t = 0 to 2*pi.
C Solution: w = 1/(z + 1.1), z = exp(it).  As z traces the unit circle,
C w traces a circle of radius 10/2.1 with center at 11/2.1.
C For convenience, Main passes RPAR = (imaginary unit i) to FEX and JEX.
C
C     EXTERNAL FEX, JEX
C     DOUBLE COMPLEX Y(2), ZWORK(24), RPAR, WTRU, ERR
C     DOUBLE PRECISION ABERR, AEMAX, ATOL, RTOL, RWORK(22), T, TOUT
C     DIMENSION IWORK(32)
C     NEQ = 2
C     Y(1) = 1.0D0/2.1D0
C     Y(2) = 1.0D0
C     T = 0.0D0
C     DTOUT = 0.1570796326794896D0
C     TOUT = DTOUT
C     ITOL = 1
C     RTOL = 1.D-9
C     ATOL = 1.D-8
C     ITASK = 1
C     ISTATE = 1
C     IOPT = 0
C     LZW = 24
C     LRW = 22
C     LIW = 32
C     MF = 21
C     RPAR = DCMPLX(0.0D0,1.0D0)
C     AEMAX = 0.0D0
C     WRITE(6,10)
C 10  FORMAT('   t',11X,'w',26X,'z')
C     DO 40 IOUT = 1,40
C       CALL ZVODE(FEX,NEQ,Y,T,TOUT,ITOL,RTOL,ATOL,ITASK,ISTATE,IOPT,
C    1             ZWORK,LZW,RWORK,LRW,IWORK,LIW,JEX,MF,RPAR,IPAR)
C       WTRU = 1.0D0/DCMPLX(COS(T) + 1.1D0, SIN(T))
C       ERR = Y(1) - WTRU
C       ABERR = ABS(DREAL(ERR)) + ABS(DIMAG(ERR))
C       AEMAX = MAX(AEMAX,ABERR)
C       WRITE(6,20) T, DREAL(Y(1)),DIMAG(Y(1)), DREAL(Y(2)),DIMAG(Y(2))
C 20    FORMAT(F9.5,2X,2F12.7,3X,2F12.7)
C       IF (ISTATE .LT. 0) THEN
C         WRITE(6,30) ISTATE
C 30      FORMAT(//'***** Error halt.  ISTATE =',I3)
C         STOP
C         ENDIF
C 40    TOUT = TOUT + DTOUT
C     WRITE(6,50) IWORK(11), IWORK(12), IWORK(13), IWORK(20),
C    1            IWORK(21), IWORK(22), IWORK(23), AEMAX
C 50  FORMAT(/' No. steps =',I4,'   No. f-s =',I5,
C    1        '   No. J-s =',I4,'   No. LU-s =',I4/
C    2        ' No. nonlinear iterations =',I4/
C    3        ' No. nonlinear convergence failures =',I4/
C    4        ' No. error test failures =',I4/
C    5        ' Max. abs. error in w =',D10.2)
C     STOP
C     END
C
C     SUBROUTINE FEX (NEQ, T, Y, YDOT, RPAR, IPAR)
C     DOUBLE COMPLEX Y(NEQ), YDOT(NEQ), RPAR
C     DOUBLE PRECISION T
C     YDOT(1) = -RPAR*Y(1)*Y(1)*Y(2)
C     YDOT(2) = RPAR*Y(2)
C     RETURN
C     END
C
C     SUBROUTINE JEX (NEQ, T, Y, ML, MU, PD, NRPD, RPAR, IPAR)
C     DOUBLE COMPLEX Y(NEQ), PD(NRPD,NEQ), RPAR
C     DOUBLE PRECISION T
C     PD(1,1) = -2.0D0*RPAR*Y(1)*Y(2)
C     PD(1,2) = -RPAR*Y(1)*Y(1)
C     PD(2,2) = RPAR
C     RETURN
C     END
C
C The output of this example program is as follows:
C
C   t           w                          z
C  0.15708     0.4763242  -0.0356919      0.9876884   0.1564345
C  0.31416     0.4767322  -0.0718256      0.9510565   0.3090170
C  0.47124     0.4774351  -0.1088651      0.8910065   0.4539906
C  0.62832     0.4784699  -0.1473206      0.8090170   0.5877853
C  0.78540     0.4798943  -0.1877789      0.7071067   0.7071069
C  0.94248     0.4817938  -0.2309414      0.5877852   0.8090171
C  1.09956     0.4842934  -0.2776778      0.4539904   0.8910066
C  1.25664     0.4875766  -0.3291039      0.3090169   0.9510566
C  1.41372     0.4919177  -0.3866987      0.1564343   0.9876884
C  1.57080     0.4977376  -0.4524889     -0.0000001   1.0000000
C  1.72788     0.5057044  -0.5293524     -0.1564346   0.9876883
C  1.88496     0.5169274  -0.6215400     -0.3090171   0.9510565
C  2.04204     0.5333540  -0.7356275     -0.4539906   0.8910065
C  2.19911     0.5586542  -0.8823669     -0.5877854   0.8090169
C  2.35619     0.6004188  -1.0806013     -0.7071069   0.7071067
C  2.51327     0.6764486  -1.3664281     -0.8090171   0.5877851
C  2.67035     0.8366909  -1.8175245     -0.8910066   0.4539904
C  2.82743     1.2657121  -2.6260146     -0.9510566   0.3090168
C  2.98451     3.0284506  -4.2182180     -0.9876884   0.1564343
C  3.14159    10.0000699   0.0000663     -1.0000000  -0.0000002
C  3.29867     3.0284170   4.2182053     -0.9876883  -0.1564346
C  3.45575     1.2657041   2.6260067     -0.9510565  -0.3090172
C  3.61283     0.8366878   1.8175205     -0.8910064  -0.4539907
C  3.76991     0.6764469   1.3664259     -0.8090169  -0.5877854
C  3.92699     0.6004178   1.0806000     -0.7071066  -0.7071069
C  4.08407     0.5586535   0.8823662     -0.5877851  -0.8090171
C  4.24115     0.5333535   0.7356271     -0.4539903  -0.8910066
C  4.39823     0.5169271   0.6215398     -0.3090168  -0.9510566
C  4.55531     0.5057041   0.5293523     -0.1564343  -0.9876884
C  4.71239     0.4977374   0.4524890      0.0000002  -1.0000000
C  4.86947     0.4919176   0.3866988      0.1564347  -0.9876883
C  5.02655     0.4875765   0.3291040      0.3090172  -0.9510564
C  5.18363     0.4842934   0.2776780      0.4539907  -0.8910064
C  5.34071     0.4817939   0.2309415      0.5877854  -0.8090169
C  5.49779     0.4798944   0.1877791      0.7071069  -0.7071066
C  5.65487     0.4784700   0.1473208      0.8090171  -0.5877850
C  5.81195     0.4774352   0.1088652      0.8910066  -0.4539903
C  5.96903     0.4767324   0.0718257      0.9510566  -0.3090168
C  6.12611     0.4763244   0.0356920      0.9876884  -0.1564342
C  6.28319     0.4761907   0.0000000      1.0000000   0.0000003
C
C No. steps = 542   No. f-s =  610   No. J-s =  10   No. LU-s =  47
C No. nonlinear iterations = 607
C No. nonlinear convergence failures =   0
C No. error test failures =  13
C Max. abs. error in w =  0.13E-03
C
C-----------------------------------------------------------------------
C Full description of user interface to ZVODE.
C
C The user interface to ZVODE consists of the following parts.
C
C i.   The call sequence to subroutine ZVODE, which is a driver
C      routine for the solver.  This includes descriptions of both
C      the call sequence arguments and of user-supplied routines.
C      Following these descriptions is
C        * a description of optional input available through the
C          call sequence,
C        * a description of optional output (in the work arrays), and
C        * instructions for interrupting and restarting a solution.
C
C ii.  Descriptions of other routines in the ZVODE package that may be
C      (optionally) called by the user.  These provide the ability to
C      alter error message handling, save and restore the internal
C      COMMON, and obtain specified derivatives of the solution y(t).
C
C iii. Descriptions of COMMON blocks to be declared in overlay
C      or similar environments.
C
C iv.  Description of two routines in the ZVODE package, either of
C      which the user may replace with his own version, if desired.
C      these relate to the measurement of errors.
C
C-----------------------------------------------------------------------
C Part i.  Call Sequence.
C
C The call sequence parameters used for input only are
C     F, NEQ, TOUT, ITOL, RTOL, ATOL, ITASK, IOPT, LRW, LIW, JAC, MF,
C and those used for both input and output are
C     Y, T, ISTATE.
C The work arrays ZWORK, RWORK, and IWORK are also used for conditional
C and optional input and optional output.  (The term output here refers
C to the return from subroutine ZVODE to the user's calling program.)
C
C The legality of input parameters will be thoroughly checked on the
C initial call for the problem, but not checked thereafter unless a
C change in input parameters is flagged by ISTATE = 3 in the input.
C
C The descriptions of the call arguments are as follows.
C
C F      = The name of the user-supplied subroutine defining the
C          ODE system.  The system must be put in the first-order
C          form dy/dt = f(t,y), where f is a vector-valued function
C          of the scalar t and the vector y.  Subroutine F is to
C          compute the function f.  It is to have the form
C               SUBROUTINE F (NEQ, T, Y, YDOT, RPAR, IPAR)
C               DOUBLE COMPLEX Y(NEQ), YDOT(NEQ)
C               DOUBLE PRECISION T
C          where NEQ, T, and Y are input, and the array YDOT = f(t,y)
C          is output.  Y and YDOT are double complex arrays of length
C          NEQ.  Subroutine F should not alter Y(1),...,Y(NEQ).
C          F must be declared EXTERNAL in the calling program.
C
C          Subroutine F may access user-defined real/complex and
C          integer work arrays RPAR and IPAR, which are to be
C          dimensioned in the calling program.
C
C          If quantities computed in the F routine are needed
C          externally to ZVODE, an extra call to F should be made
C          for this purpose, for consistent and accurate results.
C          If only the derivative dy/dt is needed, use ZVINDY instead.
C
C NEQ    = The size of the ODE system (number of first order
C          ordinary differential equations).  Used only for input.
C          NEQ may not be increased during the problem, but
C          can be decreased (with ISTATE = 3 in the input).
C
C Y      = A double precision complex array for the vector of dependent
C          variables, of length NEQ or more.  Used for both input and
C          output on the first call (ISTATE = 1), and only for output
C          on other calls.  On the first call, Y must contain the
C          vector of initial values.  In the output, Y contains the
C          computed solution evaluated at T.  If desired, the Y array
C          may be used for other purposes between calls to the solver.
C
C          This array is passed as the Y argument in all calls to
C          F and JAC.
C
C T      = The independent variable.  In the input, T is used only on
C          the first call, as the initial point of the integration.
C          In the output, after each call, T is the value at which a
C          computed solution Y is evaluated (usually the same as TOUT).
C          On an error return, T is the farthest point reached.
C
C TOUT   = The next value of t at which a computed solution is desired.
C          Used only for input.
C
C          When starting the problem (ISTATE = 1), TOUT may be equal
C          to T for one call, then should .ne. T for the next call.
C          For the initial T, an input value of TOUT .ne. T is used
C          in order to determine the direction of the integration
C          (i.e. the algebraic sign of the step sizes) and the rough
C          scale of the problem.  Integration in either direction
C          (forward or backward in t) is permitted.
C
C          If ITASK = 2 or 5 (one-step modes), TOUT is ignored after
C          the first call (i.e. the first call with TOUT .ne. T).
C          Otherwise, TOUT is required on every call.
C
C          If ITASK = 1, 3, or 4, the values of TOUT need not be
C          monotone, but a value of TOUT which backs up is limited
C          to the current internal t interval, whose endpoints are
C          TCUR - HU and TCUR.  (See optional output, below, for
C          TCUR and HU.)
C
C ITOL   = An indicator for the type of error control.  See
C          description below under ATOL.  Used only for input.
C
C RTOL   = A relative error tolerance parameter, either a scalar or
C          an array of length NEQ.  See description below under ATOL.
C          Input only.
C
C ATOL   = An absolute error tolerance parameter, either a scalar or
C          an array of length NEQ.  Input only.
C
C          The input parameters ITOL, RTOL, and ATOL determine
C          the error control performed by the solver.  The solver will
C          control the vector e = (e(i)) of estimated local errors
C          in Y, according to an inequality of the form
C                      rms-norm of ( e(i)/EWT(i) )   .le.   1,
C          where       EWT(i) = RTOL(i)*abs(Y(i)) + ATOL(i),
C          and the rms-norm (root-mean-square norm) here is
C          rms-norm(v) = sqrt(sum v(i)**2 / NEQ).  Here EWT = (EWT(i))
C          is a vector of weights which must always be positive, and
C          the values of RTOL and ATOL should all be non-negative.
C          The following table gives the types (scalar/array) of
C          RTOL and ATOL, and the corresponding form of EWT(i).
C
C             ITOL    RTOL       ATOL          EWT(i)
C              1     scalar     scalar     RTOL*ABS(Y(i)) + ATOL
C              2     scalar     array      RTOL*ABS(Y(i)) + ATOL(i)
C              3     array      scalar     RTOL(i)*ABS(Y(i)) + ATOL
C              4     array      array      RTOL(i)*ABS(Y(i)) + ATOL(i)
C
C          When either of these parameters is a scalar, it need not
C          be dimensioned in the user's calling program.
C
C          If none of the above choices (with ITOL, RTOL, and ATOL
C          fixed throughout the problem) is suitable, more general
C          error controls can be obtained by substituting
C          user-supplied routines for the setting of EWT and/or for
C          the norm calculation.  See Part iv below.
C
C          If global errors are to be estimated by making a repeated
C          run on the same problem with smaller tolerances, then all
C          components of RTOL and ATOL (i.e. of EWT) should be scaled
C          down uniformly.
C
C ITASK  = An index specifying the task to be performed.
C          Input only.  ITASK has the following values and meanings.
C          1  means normal computation of output values of y(t) at
C             t = TOUT (by overshooting and interpolating).
C          2  means take one step only and return.
C          3  means stop at the first internal mesh point at or
C             beyond t = TOUT and return.
C          4  means normal computation of output values of y(t) at
C             t = TOUT but without overshooting t = TCRIT.
C             TCRIT must be input as RWORK(1).  TCRIT may be equal to
C             or beyond TOUT, but not behind it in the direction of
C             integration.  This option is useful if the problem
C             has a singularity at or beyond t = TCRIT.
C          5  means take one step, without passing TCRIT, and return.
C             TCRIT must be input as RWORK(1).
C
C          Note:  If ITASK = 4 or 5 and the solver reaches TCRIT
C          (within roundoff), it will return T = TCRIT (exactly) to
C          indicate this (unless ITASK = 4 and TOUT comes before TCRIT,
C          in which case answers at T = TOUT are returned first).
C
C ISTATE = an index used for input and output to specify the
C          the state of the calculation.
C
C          In the input, the values of ISTATE are as follows.
C          1  means this is the first call for the problem
C             (initializations will be done).  See note below.
C          2  means this is not the first call, and the calculation
C             is to continue normally, with no change in any input
C             parameters except possibly TOUT and ITASK.
C             (If ITOL, RTOL, and/or ATOL are changed between calls
C             with ISTATE = 2, the new values will be used but not
C             tested for legality.)
C          3  means this is not the first call, and the
C             calculation is to continue normally, but with
C             a change in input parameters other than
C             TOUT and ITASK.  Changes are allowed in
C             NEQ, ITOL, RTOL, ATOL, IOPT, LRW, LIW, MF, ML, MU,
C             and any of the optional input except H0.
C             (See IWORK description for ML and MU.)
C          Note:  A preliminary call with TOUT = T is not counted
C          as a first call here, as no initialization or checking of
C          input is done.  (Such a call is sometimes useful to include
C          the initial conditions in the output.)
C          Thus the first call for which TOUT .ne. T requires
C          ISTATE = 1 in the input.
C
C          In the output, ISTATE has the following values and meanings.
C           1  means nothing was done, as TOUT was equal to T with
C              ISTATE = 1 in the input.
C           2  means the integration was performed successfully.
C          -1  means an excessive amount of work (more than MXSTEP
C              steps) was done on this call, before completing the
C              requested task, but the integration was otherwise
C              successful as far as T.  (MXSTEP is an optional input
C              and is normally 500.)  To continue, the user may
C              simply reset ISTATE to a value .gt. 1 and call again.
C              (The excess work step counter will be reset to 0.)
C              In addition, the user may increase MXSTEP to avoid
C              this error return.  (See optional input below.)
C          -2  means too much accuracy was requested for the precision
C              of the machine being used.  This was detected before
C              completing the requested task, but the integration
C              was successful as far as T.  To continue, the tolerance
C              parameters must be reset, and ISTATE must be set
C              to 3.  The optional output TOLSF may be used for this
C              purpose.  (Note: If this condition is detected before
C              taking any steps, then an illegal input return
C              (ISTATE = -3) occurs instead.)
C          -3  means illegal input was detected, before taking any
C              integration steps.  See written message for details.
C              Note:  If the solver detects an infinite loop of calls
C              to the solver with illegal input, it will cause
C              the run to stop.
C          -4  means there were repeated error test failures on
C              one attempted step, before completing the requested
C              task, but the integration was successful as far as T.
C              The problem may have a singularity, or the input
C              may be inappropriate.
C          -5  means there were repeated convergence test failures on
C              one attempted step, before completing the requested
C              task, but the integration was successful as far as T.
C              This may be caused by an inaccurate Jacobian matrix,
C              if one is being used.
C          -6  means EWT(i) became zero for some i during the
C              integration.  Pure relative error control (ATOL(i)=0.0)
C              was requested on a variable which has now vanished.
C              The integration was successful as far as T.
C
C          Note:  Since the normal output value of ISTATE is 2,
C          it does not need to be reset for normal continuation.
C          Also, since a negative input value of ISTATE will be
C          regarded as illegal, a negative output value requires the
C          user to change it, and possibly other input, before
C          calling the solver again.
C
C IOPT   = An integer flag to specify whether or not any optional
C          input is being used on this call.  Input only.
C          The optional input is listed separately below.
C          IOPT = 0 means no optional input is being used.
C                   Default values will be used in all cases.
C          IOPT = 1 means optional input is being used.
C
C ZWORK  = A double precision complex working array.
C          The length of ZWORK must be at least
C             NYH*(MAXORD + 1) + 2*NEQ + LWM    where
C          NYH    = the initial value of NEQ,
C          MAXORD = 12 (if METH = 1) or 5 (if METH = 2) (unless a
C                   smaller value is given as an optional input),
C          LWM = length of work space for matrix-related data:
C          LWM = 0             if MITER = 0,
C          LWM = 2*NEQ**2      if MITER = 1 or 2, and MF.gt.0,
C          LWM = NEQ**2        if MITER = 1 or 2, and MF.lt.0,
C          LWM = NEQ           if MITER = 3,
C          LWM = (3*ML+2*MU+2)*NEQ     if MITER = 4 or 5, and MF.gt.0,
C          LWM = (2*ML+MU+1)*NEQ       if MITER = 4 or 5, and MF.lt.0.
C          (See the MF description for METH and MITER.)
C          Thus if MAXORD has its default value and NEQ is constant,
C          this length is:
C             15*NEQ                    for MF = 10,
C             15*NEQ + 2*NEQ**2         for MF = 11 or 12,
C             15*NEQ + NEQ**2           for MF = -11 or -12,
C             16*NEQ                    for MF = 13,
C             17*NEQ + (3*ML+2*MU)*NEQ  for MF = 14 or 15,
C             16*NEQ + (2*ML+MU)*NEQ    for MF = -14 or -15,
C              8*NEQ                    for MF = 20,
C              8*NEQ + 2*NEQ**2         for MF = 21 or 22,
C              8*NEQ + NEQ**2           for MF = -21 or -22,
C              9*NEQ                    for MF = 23,
C             10*NEQ + (3*ML+2*MU)*NEQ  for MF = 24 or 25.
C              9*NEQ + (2*ML+MU)*NEQ    for MF = -24 or -25.
C
C LZW    = The length of the array ZWORK, as declared by the user.
C          (This will be checked by the solver.)
C
C RWORK  = A real working array (double precision).
C          The length of RWORK must be at least 20 + NEQ.
C          The first 20 words of RWORK are reserved for conditional
C          and optional input and optional output.
C
C          The following word in RWORK is a conditional input:
C            RWORK(1) = TCRIT = critical value of t which the solver
C                       is not to overshoot.  Required if ITASK is
C                       4 or 5, and ignored otherwise.  (See ITASK.)
C
C LRW    = The length of the array RWORK, as declared by the user.
C          (This will be checked by the solver.)
C
C IWORK  = An integer work array.  The length of IWORK must be at least
C             30        if MITER = 0 or 3 (MF = 10, 13, 20, 23), or
C             30 + NEQ  otherwise (abs(MF) = 11,12,14,15,21,22,24,25).
C          The first 30 words of IWORK are reserved for conditional and
C          optional input and optional output.
C
C          The following 2 words in IWORK are conditional input:
C            IWORK(1) = ML     These are the lower and upper
C            IWORK(2) = MU     half-bandwidths, respectively, of the
C                       banded Jacobian, excluding the main diagonal.
C                       The band is defined by the matrix locations
C                       (i,j) with i-ML .le. j .le. i+MU.  ML and MU
C                       must satisfy  0 .le.  ML,MU  .le. NEQ-1.
C                       These are required if MITER is 4 or 5, and
C                       ignored otherwise.  ML and MU may in fact be
C                       the band parameters for a matrix to which
C                       df/dy is only approximately equal.
C
C LIW    = the length of the array IWORK, as declared by the user.
C          (This will be checked by the solver.)
C
C Note:  The work arrays must not be altered between calls to ZVODE
C for the same problem, except possibly for the conditional and
C optional input, and except for the last 2*NEQ words of ZWORK and
C the last NEQ words of RWORK.  The latter space is used for internal
C scratch space, and so is available for use by the user outside ZVODE
C between calls, if desired (but not for use by F or JAC).
C
C JAC    = The name of the user-supplied routine (MITER = 1 or 4) to
C          compute the Jacobian matrix, df/dy, as a function of
C          the scalar t and the vector y.  It is to have the form
C               SUBROUTINE JAC (NEQ, T, Y, ML, MU, PD, NROWPD,
C                               RPAR, IPAR)
C               DOUBLE COMPLEX Y(NEQ), PD(NROWPD,NEQ)
C               DOUBLE PRECISION T
C          where NEQ, T, Y, ML, MU, and NROWPD are input and the array
C          PD is to be loaded with partial derivatives (elements of the
C          Jacobian matrix) in the output.  PD must be given a first
C          dimension of NROWPD.  T and Y have the same meaning as in
C          Subroutine F.
C               In the full matrix case (MITER = 1), ML and MU are
C          ignored, and the Jacobian is to be loaded into PD in
C          columnwise manner, with df(i)/dy(j) loaded into PD(i,j).
C               In the band matrix case (MITER = 4), the elements
C          within the band are to be loaded into PD in columnwise
C          manner, with diagonal lines of df/dy loaded into the rows
C          of PD. Thus df(i)/dy(j) is to be loaded into PD(i-j+MU+1,j).
C          ML and MU are the half-bandwidth parameters. (See IWORK).
C          The locations in PD in the two triangular areas which
C          correspond to nonexistent matrix elements can be ignored
C          or loaded arbitrarily, as they are overwritten by ZVODE.
C               JAC need not provide df/dy exactly.  A crude
C          approximation (possibly with a smaller bandwidth) will do.
C               In either case, PD is preset to zero by the solver,
C          so that only the nonzero elements need be loaded by JAC.
C          Each call to JAC is preceded by a call to F with the same
C          arguments NEQ, T, and Y.  Thus to gain some efficiency,
C          intermediate quantities shared by both calculations may be
C          saved in a user COMMON block by F and not recomputed by JAC,
C          if desired.  Also, JAC may alter the Y array, if desired.
C          JAC must be declared external in the calling program.
C               Subroutine JAC may access user-defined real/complex and
C          integer work arrays, RPAR and IPAR, whose dimensions are set
C          by the user in the calling program.
C
C MF     = The method flag.  Used only for input.  The legal values of
C          MF are 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25,
C          -11, -12, -14, -15, -21, -22, -24, -25.
C          MF is a signed two-digit integer, MF = JSV*(10*METH + MITER).
C          JSV = SIGN(MF) indicates the Jacobian-saving strategy:
C            JSV =  1 means a copy of the Jacobian is saved for reuse
C                     in the corrector iteration algorithm.
C            JSV = -1 means a copy of the Jacobian is not saved
C                     (valid only for MITER = 1, 2, 4, or 5).
C          METH indicates the basic linear multistep method:
C            METH = 1 means the implicit Adams method.
C            METH = 2 means the method based on backward
C                     differentiation formulas (BDF-s).
C          MITER indicates the corrector iteration method:
C            MITER = 0 means functional iteration (no Jacobian matrix
C                      is involved).
C            MITER = 1 means chord iteration with a user-supplied
C                      full (NEQ by NEQ) Jacobian.
C            MITER = 2 means chord iteration with an internally
C                      generated (difference quotient) full Jacobian
C                      (using NEQ extra calls to F per df/dy value).
C            MITER = 3 means chord iteration with an internally
C                      generated diagonal Jacobian approximation
C                      (using 1 extra call to F per df/dy evaluation).
C            MITER = 4 means chord iteration with a user-supplied
C                      banded Jacobian.
C            MITER = 5 means chord iteration with an internally
C                      generated banded Jacobian (using ML+MU+1 extra
C                      calls to F per df/dy evaluation).
C          If MITER = 1 or 4, the user must supply a subroutine JAC
C          (the name is arbitrary) as described above under JAC.
C          For other values of MITER, a dummy argument can be used.
C
C RPAR     User-specified array used to communicate real or complex
C          parameters to user-supplied subroutines.  If RPAR is an
C          array, it must be dimensioned in the user's calling program;
C          if it is unused or it is a scalar, then it need not be
C          dimensioned.  The type of RPAR may be REAL, DOUBLE, COMPLEX,
C          or DOUBLE COMPLEX, depending on the user program's needs.
C          RPAR is not type-declared within ZVODE, but simply passed
C          (by address) to the user's F and JAC routines.
C
C IPAR     User-specified array used to communicate integer parameter
C          to user-supplied subroutines.  If IPAR is an array, it must
C          be dimensioned in the user's calling program.
C-----------------------------------------------------------------------
C Optional Input.
C
C The following is a list of the optional input provided for in the
C call sequence.  (See also Part ii.)  For each such input variable,
C this table lists its name as used in this documentation, its
C location in the call sequence, its meaning, and the default value.
C The use of any of this input requires IOPT = 1, and in that
C case all of this input is examined.  A value of zero for any
C of these optional input variables will cause the default value to be
C used.  Thus to use a subset of the optional input, simply preload
C locations 5 to 10 in RWORK and IWORK to 0.0 and 0 respectively, and
C then set those of interest to nonzero values.
C
C NAME    LOCATION      MEANING AND DEFAULT VALUE
C
C H0      RWORK(5)  The step size to be attempted on the first step.
C                   The default value is determined by the solver.
C
C HMAX    RWORK(6)  The maximum absolute step size allowed.
C                   The default value is infinite.
C
C HMIN    RWORK(7)  The minimum absolute step size allowed.
C                   The default value is 0.  (This lower bound is not
C                   enforced on the final step before reaching TCRIT
C                   when ITASK = 4 or 5.)
C
C MAXORD  IWORK(5)  The maximum order to be allowed.  The default
C                   value is 12 if METH = 1, and 5 if METH = 2.
C                   If MAXORD exceeds the default value, it will
C                   be reduced to the default value.
C                   If MAXORD is changed during the problem, it may
C                   cause the current order to be reduced.
C
C MXSTEP  IWORK(6)  Maximum number of (internally defined) steps
C                   allowed during one call to the solver.
C                   The default value is 500.
C
C MXHNIL  IWORK(7)  Maximum number of messages printed (per problem)
C                   warning that T + H = T on a step (H = step size).
C                   This must be positive to result in a non-default
C                   value.  The default value is 10.
C
C-----------------------------------------------------------------------
C Optional Output.
C
C As optional additional output from ZVODE, the variables listed
C below are quantities related to the performance of ZVODE
C which are available to the user.  These are communicated by way of
C the work arrays, but also have internal mnemonic names as shown.
C Except where stated otherwise, all of this output is defined
C on any successful return from ZVODE, and on any return with
C ISTATE = -1, -2, -4, -5, or -6.  On an illegal input return
C (ISTATE = -3), they will be unchanged from their existing values
C (if any), except possibly for TOLSF, LENZW, LENRW, and LENIW.
C On any error return, output relevant to the error will be defined,
C as noted below.
C
C NAME    LOCATION      MEANING
C
C HU      RWORK(11) The step size in t last used (successfully).
C
C HCUR    RWORK(12) The step size to be attempted on the next step.
C
C TCUR    RWORK(13) The current value of the independent variable
C                   which the solver has actually reached, i.e. the
C                   current internal mesh point in t.  In the output,
C                   TCUR will always be at least as far from the
C                   initial value of t as the current argument T,
C                   but may be farther (if interpolation was done).
C
C TOLSF   RWORK(14) A tolerance scale factor, greater than 1.0,
C                   computed when a request for too much accuracy was
C                   detected (ISTATE = -3 if detected at the start of
C                   the problem, ISTATE = -2 otherwise).  If ITOL is
C                   left unaltered but RTOL and ATOL are uniformly
C                   scaled up by a factor of TOLSF for the next call,
C                   then the solver is deemed likely to succeed.
C                   (The user may also ignore TOLSF and alter the
C                   tolerance parameters in any other way appropriate.)
C
C NST     IWORK(11) The number of steps taken for the problem so far.
C
C NFE     IWORK(12) The number of f evaluations for the problem so far.
C
C NJE     IWORK(13) The number of Jacobian evaluations so far.
C
C NQU     IWORK(14) The method order last used (successfully).
C
C NQCUR   IWORK(15) The order to be attempted on the next step.
C
C IMXER   IWORK(16) The index of the component of largest magnitude in
C                   the weighted local error vector ( e(i)/EWT(i) ),
C                   on an error return with ISTATE = -4 or -5.
C
C LENZW   IWORK(17) The length of ZWORK actually required.
C                   This is defined on normal returns and on an illegal
C                   input return for insufficient storage.
C
C LENRW   IWORK(18) The length of RWORK actually required.
C                   This is defined on normal returns and on an illegal
C                   input return for insufficient storage.
C
C LENIW   IWORK(19) The length of IWORK actually required.
C                   This is defined on normal returns and on an illegal
C                   input return for insufficient storage.
C
C NLU     IWORK(20) The number of matrix LU decompositions so far.
C
C NNI     IWORK(21) The number of nonlinear (Newton) iterations so far.
C
C NCFN    IWORK(22) The number of convergence failures of the nonlinear
C                   solver so far.
C
C NETF    IWORK(23) The number of error test failures of the integrator
C                   so far.
C
C The following two arrays are segments of the ZWORK array which
C may also be of interest to the user as optional output.
C For each array, the table below gives its internal name,
C its base address in ZWORK, and its description.
C
C NAME    BASE ADDRESS      DESCRIPTION
C
C YH       1             The Nordsieck history array, of size NYH by
C                        (NQCUR + 1), where NYH is the initial value
C                        of NEQ.  For j = 0,1,...,NQCUR, column j+1
C                        of YH contains HCUR**j/factorial(j) times
C                        the j-th derivative of the interpolating
C                        polynomial currently representing the
C                        solution, evaluated at t = TCUR.
C
C ACOR     LENZW-NEQ+1   Array of size NEQ used for the accumulated
C                        corrections on each step, scaled in the output
C                        to represent the estimated local error in Y
C                        on the last step.  This is the vector e in
C                        the description of the error control.  It is
C                        defined only on a successful return from ZVODE.
C
C-----------------------------------------------------------------------
C Interrupting and Restarting
C
C If the integration of a given problem by ZVODE is to be
C interrrupted and then later continued, such as when restarting
C an interrupted run or alternating between two or more ODE problems,
C the user should save, following the return from the last ZVODE call
C prior to the interruption, the contents of the call sequence
C variables and internal COMMON blocks, and later restore these
C values before the next ZVODE call for that problem.  To save
C and restore the COMMON blocks, use subroutine ZVSRCO, as
C described below in part ii.
C
C In addition, if non-default values for either LUN or MFLAG are
C desired, an extra call to XSETUN and/or XSETF should be made just
C before continuing the integration.  See Part ii below for details.
C
C-----------------------------------------------------------------------
C Part ii.  Other Routines Callable.
C
C The following are optional calls which the user may make to
C gain additional capabilities in conjunction with ZVODE.
C (The routines XSETUN and XSETF are designed to conform to the
C SLATEC error handling package.)
C
C     FORM OF CALL                  FUNCTION
C  CALL XSETUN(LUN)           Set the logical unit number, LUN, for
C                             output of messages from ZVODE, if
C                             the default is not desired.
C                             The default value of LUN is 6.
C
C  CALL XSETF(MFLAG)          Set a flag to control the printing of
C                             messages by ZVODE.
C                             MFLAG = 0 means do not print. (Danger:
C                             This risks losing valuable information.)
C                             MFLAG = 1 means print (the default).
C
C                             Either of the above calls may be made at
C                             any time and will take effect immediately.
C
C  CALL ZVSRCO(RSAV,ISAV,JOB) Saves and restores the contents of
C                             the internal COMMON blocks used by
C                             ZVODE. (See Part iii below.)
C                             RSAV must be a real array of length 51
C                             or more, and ISAV must be an integer
C                             array of length 40 or more.
C                             JOB=1 means save COMMON into RSAV/ISAV.
C                             JOB=2 means restore COMMON from RSAV/ISAV.
C                                ZVSRCO is useful if one is
C                             interrupting a run and restarting
C                             later, or alternating between two or
C                             more problems solved with ZVODE.
C
C  CALL ZVINDY(,,,,,)         Provide derivatives of y, of various
C        (See below.)         orders, at a specified point T, if
C                             desired.  It may be called only after
C                             a successful return from ZVODE.
C
C The detailed instructions for using ZVINDY are as follows.
C The form of the call is:
C
C  CALL ZVINDY (T, K, ZWORK, NYH, DKY, IFLAG)
C
C The input parameters are:
C
C T         = Value of independent variable where answers are desired
C             (normally the same as the T last returned by ZVODE).
C             For valid results, T must lie between TCUR - HU and TCUR.
C             (See optional output for TCUR and HU.)
C K         = Integer order of the derivative desired.  K must satisfy
C             0 .le. K .le. NQCUR, where NQCUR is the current order
C             (see optional output).  The capability corresponding
C             to K = 0, i.e. computing y(T), is already provided
C             by ZVODE directly.  Since NQCUR .ge. 1, the first
C             derivative dy/dt is always available with ZVINDY.
C ZWORK     = The history array YH.
C NYH       = Column length of YH, equal to the initial value of NEQ.
C
C The output parameters are:
C
C DKY       = A double complex array of length NEQ containing the
C             computed value of the K-th derivative of y(t).
C IFLAG     = Integer flag, returned as 0 if K and T were legal,
C             -1 if K was illegal, and -2 if T was illegal.
C             On an error return, a message is also written.
C-----------------------------------------------------------------------
C Part iii.  COMMON Blocks.
C If ZVODE is to be used in an overlay situation, the user
C must declare, in the primary overlay, the variables in:
C   (1) the call sequence to ZVODE,
C   (2) the two internal COMMON blocks
C         /ZVOD01/  of length  83  (50 double precision words
C                         followed by 33 integer words),
C         /ZVOD02/  of length  9  (1 double precision word
C                         followed by 8 integer words),
C
C If ZVODE is used on a system in which the contents of internal
C COMMON blocks are not preserved between calls, the user should
C declare the above two COMMON blocks in his calling program to insure
C that their contents are preserved.
C
C-----------------------------------------------------------------------
C Part iv.  Optionally Replaceable Solver Routines.
C
C Below are descriptions of two routines in the ZVODE package which
C relate to the measurement of errors.  Either routine can be
C replaced by a user-supplied version, if desired.  However, since such
C a replacement may have a major impact on performance, it should be
C done only when absolutely necessary, and only with great caution.
C (Note: The means by which the package version of a routine is
C superseded by the user's version may be system-dependent.)
C
C (a) ZEWSET.
C The following subroutine is called just before each internal
C integration step, and sets the array of error weights, EWT, as
C described under ITOL/RTOL/ATOL above:
C     SUBROUTINE ZEWSET (NEQ, ITOL, RTOL, ATOL, YCUR, EWT)
C where NEQ, ITOL, RTOL, and ATOL are as in the ZVODE call sequence,
C YCUR contains the current (double complex) dependent variable vector,
C and EWT is the array of weights set by ZEWSET.
C
C If the user supplies this subroutine, it must return in EWT(i)
C (i = 1,...,NEQ) a positive quantity suitable for comparison with
C errors in Y(i).  The EWT array returned by ZEWSET is passed to the
C ZVNORM routine (See below.), and also used by ZVODE in the computation
C of the optional output IMXER, the diagonal Jacobian approximation,
C and the increments for difference quotient Jacobians.
C
C In the user-supplied version of ZEWSET, it may be desirable to use
C the current values of derivatives of y.  Derivatives up to order NQ
C are available from the history array YH, described above under
C Optional Output.  In ZEWSET, YH is identical to the YCUR array,
C extended to NQ + 1 columns with a column length of NYH and scale
C factors of h**j/factorial(j).  On the first call for the problem,
C given by NST = 0, NQ is 1 and H is temporarily set to 1.0.
C NYH is the initial value of NEQ.  The quantities NQ, H, and NST
C can be obtained by including in ZEWSET the statements:
C     DOUBLE PRECISION RVOD, H, HU
C     COMMON /ZVOD01/ RVOD(50), IVOD(33)
C     COMMON /ZVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C     NQ = IVOD(28)
C     H = RVOD(21)
C Thus, for example, the current value of dy/dt can be obtained as
C YCUR(NYH+i)/H  (i=1,...,NEQ)  (and the division by H is
C unnecessary when NST = 0).
C
C (b) ZVNORM.
C The following is a real function routine which computes the weighted
C root-mean-square norm of a vector v:
C     D = ZVNORM (N, V, W)
C where:
C   N = the length of the vector,
C   V = double complex array of length N containing the vector,
C   W = real array of length N containing weights,
C   D = sqrt( (1/N) * sum(abs(V(i))*W(i))**2 ).
C ZVNORM is called with N = NEQ and with W(i) = 1.0/EWT(i), where
C EWT is as set by subroutine ZEWSET.
C
C If the user supplies this function, it should return a non-negative
C value of ZVNORM suitable for use in the error control in ZVODE.
C None of the arguments should be altered by ZVNORM.
C For example, a user-supplied ZVNORM routine might:
C   -substitute a max-norm of (V(i)*W(i)) for the rms-norm, or
C   -ignore some components of V in the norm, with the effect of
C    suppressing the error control on those components of Y.
C-----------------------------------------------------------------------
C REVISION HISTORY (YYYYMMDD)
C  20060517  DATE WRITTEN, modified from DVODE of 20020430.
C  20061227  Added note on use for analytic f.
C-----------------------------------------------------------------------
C Other Routines in the ZVODE Package.
C
C In addition to Subroutine ZVODE, the ZVODE package includes the
C following subroutines and function routines:
C  ZVHIN     computes an approximate step size for the initial step.
C  ZVINDY    computes an interpolated value of the y vector at t = TOUT.
C  ZVSTEP    is the core integrator, which does one step of the
C            integration and the associated error control.
C  ZVSET     sets all method coefficients and test constants.
C  ZVNLSD    solves the underlying nonlinear system -- the corrector.
C  ZVJAC     computes and preprocesses the Jacobian matrix J = df/dy
C            and the Newton iteration matrix P = I - (h/l1)*J.
C  ZVSOL     manages solution of linear system in chord iteration.
C  ZVJUST    adjusts the history array on a change of order.
C  ZEWSET    sets the error weight vector EWT before each step.
C  ZVNORM    computes the weighted r.m.s. norm of a vector.
C  ZABSSQ    computes the squared absolute value of a double complex z.
C  ZVSRCO    is a user-callable routine to save and restore
C            the contents of the internal COMMON blocks.
C  ZACOPY    is a routine to copy one two-dimensional array to another.
C  ZGEFA and ZGESL   are routines from LINPACK for solving full
C            systems of linear algebraic equations.
C  ZGBFA and ZGBSL   are routines from LINPACK for solving banded
C            linear systems.
C  DZSCAL    scales a double complex array by a double prec. scalar.
C  DZAXPY    adds a D.P. scalar times one complex vector to another.
C  ZCOPY     is a basic linear algebra module from the BLAS.
C  DUMACH    sets the unit roundoff of the machine.
C  XERRWD, XSETUN, XSETF, IXSAV, and IUMACH handle the printing of all
C            error messages and warnings.  XERRWD is machine-dependent.
C Note: ZVNORM, ZABSSQ, DUMACH, IXSAV, and IUMACH are function routines.
C All the others are subroutines.
C The intrinsic functions called with double precision complex arguments
C are: ABS, DREAL, and DIMAG.  All of these are expected to return
C double precision real values.
C
